#!/usr/bin/env ts-node
import fs from 'fs'
import path from 'path'
import { exit } from 'process'

const objectToEnvLines = (obj: { [key: string]: string }) => {
  const entries = Object.entries(obj)
  return entries.reduce((sum, [key, value]) => {
    return `${sum}${key}=${value} `
  }, '')
}

const getENVVars = async (targetFile: string) => {
  let currentDir = __dirname

  while (!fs.existsSync(path.join(currentDir, targetFile))) {
    if (currentDir === '/') {
      console.error(`unable to find '${targetFile}' in a parent directory`)
      return exit(1)
    }
    currentDir = path.join(currentDir, '..')
  }

  const { envVars } = await import(path.join(currentDir, targetFile))
  return envVars
}

export const main = async (sourceENVFile: string, targetENVSubRepo: string) => {
  const envVars = await getENVVars(sourceENVFile)
  const validEnvs = Object.keys(envVars)

  if (!validEnvs.includes(targetENVSubRepo)) {
    console.error('Second command line arg must be a valid repo')
    return exit(1)
  }

  const targetVars = envVars[targetENVSubRepo as any] as any

  const envString = objectToEnvLines(targetVars)
  return envString
}

const getListofEnvVars = (repo: string): string[] => {
  let currentDir = __dirname

  while (!fs.existsSync(path.join(currentDir, 'envTypes.ts'))) {
    if (currentDir === '/') {
      console.error('unable to find `envTypes.ts` in a parent directory')
      return exit(1)
    }
    currentDir = path.join(currentDir, '..')
  }

  const file = fs.readFileSync(path.join(currentDir, 'envTypes.ts'), 'utf8')
  const lines = file.split('ENVTypes = {')[1].split('\n')

  const varsNeeded: { [name in string]?: string[] } = {}
  let currentTarget: string | null = null
  lines.forEach((_line) => {
    const line = _line.trim()
    if (line === '') return
    if (line.startsWith('/**') || line.startsWith('*')) return
    if (line.startsWith('//')) return
    if (line.endsWith('{')) {
      currentTarget = line.split(':')[0]
      return
    }
    if (line.endsWith('}')) {
      currentTarget = null
      return
    }
    if (currentTarget == null) {
      throw new Error(`cannot process line with currentTarget null: ${line}`)
    }
    const varName = line.split(':')[0]
    if (!varsNeeded[currentTarget]) {
      varsNeeded[currentTarget] = []
    }
    varsNeeded[currentTarget]?.push(varName)
  })

  const res = varsNeeded[repo]
  if (!res) throw new Error('invalid repo')
  return res
}

export const __internal_for_testing__ = { getListofEnvVars }

export const generateENVFile = (repo: string, fileSrc: string, prefix = '') => {
  const repoVars = getListofEnvVars(repo).filter((i) => i.startsWith(prefix))

  const file = `/* eslint-disable */
/*
 * This file is auto-generated by env-ts
 * Do not edit
 */
${repoVars
  .map(
    (i) =>
      `
if (process.env.${i} == null) {
  throw new Error('missing process.env.${i} in ${repo}')
}`,
  )
  .join('')}

export const env = {
  ${repoVars.map((i) => `${i}: process.env.${i},`).join('\n')}
}
`

  fs.writeFileSync(path.join(process.cwd(), fileSrc), file, 'utf8')
}
